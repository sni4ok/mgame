/*
    This file contains script for generating c++ types from plaza2 ini schemes

    author: Ilya Andronov <sni4ok@yandex.ru>
*/

#include "evie/utils.hpp"
#include "evie/mfile.hpp"

#include <map>
#include <set>
#include <iostream>
#include <fstream>
#include <memory>

#include <dirent.h>

typedef std::pair<std::string, std::string> namespace_type;

struct source_file : std::ofstream
{
    source_file(const std::string& out_file) : std::ofstream(out_file.c_str(), std::ios::trunc) {
        exceptions(std::ios::badbit | std::ios::failbit);
        (*this) << "//autogenerated by plaza_templater" << std::endl << std::endl
            << "#pragma once" << std::endl
            << "#pragma pack(push, 4)" << std::endl << std::endl;
    }
    ~source_file() {
        (*this) << "#pragma pack(pop)" << std::endl << std::endl;
    }
};

struct context
{
    namespace_type cur_namespace, saved_namespace;
    std::string table_name;
    std::map<namespace_type, std::map<std::string, std::string> > saved_structures;
    source_file sf;
    std::ofstream* fi;

    context(const std::string& out_file) : sf(out_file), fi()
    {
    }
    virtual bool need_save() {
        return true;
    }
};

uint32_t cg_decimal_size(uint32_t m, uint32_t e) {
    return 2 + (m >> 1) + ((m | e) & 1); 
}

template<typename t>
struct optional
{
    bool set;
    t val;
    optional() : set() {
    }
    optional(const t& v) : set(true), val(v) {
    }
    optional& operator=(const optional& v) {
        val = v.val;
        set = v.set;
        return *this;
    }
    operator bool () const {
        return set;
    }
    const t& operator*() const {
        if(!set)
            throw std::logic_error("optional::operator* value not set");
        return val;
    }
};

struct skelet
{
    optional<uint32_t> msgid;
    optional<bool> request, reply;
    std::vector<uint32_t> replies;
    std::vector<std::tuple<std::string, std::string, optional<std::string> > > types;
    uint32_t structure_size;
    bool have_alignment;
    std::string nullable; //WTF IS THIS ?????
    void add_size(uint32_t sz, uint32_t granularity) {
        granularity = std::min(uint32_t(4), granularity);
        uint32_t st_from = structure_size % granularity;
        if(st_from)
            structure_size += (granularity - st_from);
        structure_size += sz;
    }
    std::set<std::string> c_types;
    void close_structure_size() {
        uint32_t st_from = structure_size % 4;
        if(st_from && c_types.size() > 1)
            structure_size += (4 - st_from);
    }
    skelet() : structure_size(), have_alignment() {
    }
    void set_nullable(const std::string& data) {
        nullable = data;
    }
    void clear() {
        msgid = optional<uint32_t>();
        request = optional<bool>();
        reply = optional<bool>();
        replies.clear();
        types.clear();
        c_types.clear();
        structure_size = 0;
    }
    std::string convert_type(const std::string& ini_type) {
        if(ini_type.empty())
            throw std::runtime_error("empty ini_type!");
        if(ini_type == "i8") {
            add_size(8, 8);
            c_types.insert("int64_t");
            return "int64_t";
        }
        if(ini_type == "u8") {
            add_size(8, 8);
            c_types.insert("uint64_t");
            return "uint64_t";
        }
        if(ini_type == "i4") {
            add_size(4, 4);
            c_types.insert("int32_t");
            return "int32_t";
        }
        if(ini_type == "i2") {
            add_size(2, 2);
            c_types.insert("int16_t");
            return "int16_t";
        }
        if(ini_type == "i1") {
            add_size(1, 1);
            c_types.insert("int8_t");
            return "int8_t";
        }
        if(ini_type == "u1") {
            add_size(1, 1);
            c_types.insert("uint8_t");
            return "uint8_t";
        }
        if(ini_type == "f") {
            add_size(8, 8);
            c_types.insert("double");
            return "double";
        }
        if(ini_type == "t") {
            add_size(10, 2);
            c_types.insert("uint8_t");
            c_types.insert("uint16_t");
            return "cg_time_t";
        }
        if(ini_type[0] == 'c') {
            std::string v(ini_type.begin() + 1, ini_type.end());
            uint32_t vs = lexical_cast<uint32_t>(v);
            add_size(vs + 1, 1);
            std::string ret = std::string("cg_string<") + v + ">";
            c_types.insert("char");
            return ret;
        }
        if(ini_type[0] == 'd') {
            std::string::const_iterator p = std::find(ini_type.begin() + 1, ini_type.end(), '.');
            std::string ms = std::string(ini_type.begin() + 1, p);
            uint32_t m = lexical_cast<uint32_t>(ms);
            std::string es = std::string(p + 1, ini_type.end());
            uint32_t e = lexical_cast<uint32_t>(std::string(p + 1, ini_type.end()));
            add_size(cg_decimal_size(m, e), 1);
            std::string ret = std::string("cg_decimal<") + ms + "," + es + ">";
            c_types.insert("char");
            return ret;
        }
        throw std::runtime_error(es() % "unknown ini_type: " % ini_type);
    }
    void add_field(const std::string& data) {
        std::vector<std::string> tmp = split(data, ',');
        if(tmp.size() != 2 && tmp.size() != 4)
            throw std::runtime_error(es() % "bad add_field: " % data);
        if(tmp.size() == 4 && !tmp[2].empty())
            std::cout << data << std::endl;
        std::tuple<std::string, std::string, optional<std::string> > v;
        std::get<0>(v) = tmp[0];
        std::get<1>(v) = convert_type(tmp[1]);
        if(tmp.size() == 4)
            std::get<2>(v) = tmp[3];
        types.push_back(v);
    }
    void set_replies(const std::string& data) {
        if(data.empty())
            return;
        if(!replies.empty())
            throw std::runtime_error("replies already exists");
        std::vector<std::string> tmp = split(data, ',');
        for(const auto& s: tmp)
            replies.push_back(lexical_cast<uint32_t>(s));
    }
    template<typename value>
    static void write_body_value(std::ostream& of, const std::string& type, const value& v) {
        of << "        " << type << " " << v << ";" << std::endl;
    }
    void clear_and_close_namespace(context& ctx, bool end) {
        clear();
        if(end) {
            if(!ctx.saved_namespace.first.empty())
                ctx.sf << "}";
            if(!ctx.saved_namespace.second.empty())
                ctx.sf << "}" << std::endl;
            
            ctx.saved_namespace = namespace_type();
        }
    }
    void commit(context& ctx, bool end, std::vector<char>::const_iterator i_f, std::vector<char>::const_iterator i_t) {
        if(types.empty() || !ctx.need_save()) {
            clear_and_close_namespace(ctx, end);
            return;
        }
        if(ctx.fi)
            ctx.fi->write(&(*i_f), i_t - i_f);
        if(ctx.saved_namespace != ctx.cur_namespace) {
            if(ctx.saved_namespace.first == ctx.cur_namespace.first) {
                if(!ctx.saved_namespace.second.empty())
                    ctx.sf << "}" << std::endl;
                ctx.sf << "namespace " << ctx.cur_namespace.second << std::endl << "{" << std::endl;
            }
            else{
                if(!ctx.saved_namespace.first.empty())
                    ctx.sf << "}";
                if(!ctx.saved_namespace.second.empty())
                    ctx.sf << "}" << std::endl;
                ctx.sf << "namespace " << ctx.cur_namespace.first << std::endl << "{ " << std::endl << "namespace "
                    << ctx.cur_namespace.second << std::endl << "{" << std::endl;
            }
            ctx.saved_namespace = ctx.cur_namespace;
        }
        std::stringstream str;
        str << "    struct " << ctx.table_name << std::endl << "    {" << std::endl;
        write_body_value(str, "static constexpr uint32_t plaza_size =", structure_size);
        if(msgid)
            write_body_value(str, "static constexpr uint32_t msgid =", *msgid);
        if(request)
            write_body_value(str, "static constexpr bool request =", *request);
        if(reply)
            write_body_value(str, "static constexpr bool reply =", *reply);
        if(!replies.empty()) {
            std::stringstream type;
            type << "//typedef mpl::vector_c<uint32_t";
            for(auto s: replies)
                type << ", " << s;
            type << ">";
            write_body_value(str, type.str(), "replies");
        }
        if(!nullable.empty())
            write_body_value(str, "//nullable =", nullable);
        for(const auto& v: types) {
            write_body_value(str, std::get<1>(v), std::get<0>(v));
        }
        if(reply) {
            str << "        void print(mlog& ml) {" << std::endl <<  "            ml << \"" << ctx.table_name << "\"";
            for(const auto& v: types) {
                str << " << \", " <<  std::get<0>(v) << ": \" << " << std::get<0>(v);
            }
            str << ";" << std::endl << "        }" << std::endl;
        }
        {

            str << "        void print_brief() {" << std::endl <<  "            mlog() << \"" << ctx.table_name << "|\"";
            uint32_t cur_i = 0;
            for(const auto& v: types) {
                if(cur_i && !(cur_i % 5)) {
                    str << std::endl << "              ";
                }
                str << " << " << std::get<0>(v) << " << \"|\"";
                ++cur_i;
            }
            str << ";" << std::endl << "        }" << std::endl;
        }
        {
            bool have_init = false;
            for(const auto& v: types) {
                if(std::get<2>(v)) {
                    have_init = true;
                    break;
                }
            }
            if(have_init) {
                //write constructor
                str << "        " << ctx.table_name << "() :";
                uint32_t cur_i = 0;
                for(const auto& v: types) {
                    if(std::get<2>(v)) {
                        if(cur_i)
                            str << ", ";
                        if(!(cur_i % 5)) {
                            str << std::endl << "          ";
                        }
                        str << std::get<0>(v) << "(";
                        str << *std::get<2>(v);
                        str <<  ")";
                        ++cur_i;
                    }
                }
                str << std::endl << "        {" << std::endl << "        }" << std::endl;
            }
        }
        close_structure_size();
        str << "    };" << std::endl;
        str << "    static_assert(sizeof(" << ctx.table_name << ") == " << structure_size << ", \"" << ctx.table_name << "\");" << std::endl;
        std::map<std::string, std::string>& cur = ctx.saved_structures[ctx.cur_namespace];
        std::string cur_str = str.str();
        auto it = cur.find(ctx.table_name);
        if(it == cur.end()) {
            bool found = false;
            for(const auto& i : ctx.saved_structures) {
                auto ii = i.second.find(ctx.table_name);
                if(ii != i.second.end() && ii->second == cur_str) {
                    found = true;
                    ctx.sf << "    using " << i.first.first << "::" << i.first.second << "::" << ctx.table_name << ";" << std::endl;
                    break;
                }
            }
            if(!found) {
                ctx.sf.write(cur_str.c_str(), cur_str.size());
                cur[ctx.table_name] = cur_str;
            }
        }
        else{
            if(it->second != cur_str) {
                std::cerr << "bad redinfication of struct: " << ctx.cur_namespace.first << "::"
                    << ctx.cur_namespace.second << "::" << ctx.table_name << std::endl;
                ctx.sf << "    //struct " << ctx.table_name << " badly defined early" << std::endl;
            }
            else
                ctx.sf << "    //struct " << ctx.table_name << " already defined early" << std::endl;
        }
        clear_and_close_namespace(ctx, end);
    }
};

void check_no_endl(const std::string& v)
{
    std::string::const_iterator it = std::find(v.begin(), v.end(), '\n');
    if(it != v.end())
        throw std::runtime_error(es() % "string with endl, parse error: " % v);
}

void parse_file(context& ctx, const std::vector<char>& data)
{
    std::vector<char>::const_iterator it = data.begin(), it_e = data.end(), it_tmp, ini_from = it;
    skelet sk;
    //const std::string stream_name = "\x20\xCF\xEE\xF2\xEE\xEA\x20"; //" Potok "
    const std::string stream_name = "\x20\xD0\x9F\xD0\xBE\xD1\x82\xD0\xBE\xD0\xBA\x20"; //" Potok "
    while(it != it_e) {
        while(it != it_e && (*it == '\r' || *it == '\n'))
            ++it;
        if(it != it_e && *it == ';') {
            ++it;
            std::string::const_iterator i = stream_name.begin(), ie = stream_name.end();
            while(it != it_e && i != ie) {
                if(*it != *i)
                    break;
                ++it;
                ++i;
            }
            if(i == ie) {
                sk.commit(ctx, false, ini_from, it);
                it_tmp = std::find(it, it_e, ' ');
                ctx.cur_namespace.first = std::string(it, it_tmp);
            }

            while(it != it_e && *it != '\n')
                ++it;
            continue;
        }
        if(it == it_e)
            break;
        if(it != it_e && *it == '[') {
            it_tmp = std::find(++it, it_e, ':');
            if(it_tmp == it_e) break;
            sk.commit(ctx, false, ini_from, it - 1);
            ini_from = it - 1;
            if(std::string(it, it_tmp) == "table") {
                it = it_tmp + 1;
                it_tmp = std::find(it, it_e, ':');
                if(it_tmp == it_e)
                    throw std::runtime_error("parsing error 1");
                ctx.cur_namespace.second = std::string(it, it_tmp);
                check_no_endl(ctx.cur_namespace.second);
                it = it_tmp + 1;
                it_tmp = std::find(it, it_e, ']');
                if(it_tmp == it_e)
                    throw std::runtime_error("parsing error 2");
                ctx.table_name = std::string(it, it_tmp);
                check_no_endl(ctx.table_name);
            }
            it = it_tmp + 1;
            it = std::find_if(it, it_e, [](char c) {return c == '\r' || c == '\n';});
            continue;
        }
        {
            it_tmp = std::find(it, it_e, '=');
            if(it_tmp == it_e)
                throw std::runtime_error("parsing error 3");
            std::string type(it, it_tmp);
            while(!type.empty() && *type.rbegin() == ' ')
                type.pop_back();
            check_no_endl(type);
            it = it_tmp + 1;
            if(it == it_e)
                throw std::runtime_error("parsing error 4");
            it_tmp = std::find_if(it, it_e, [](char c) {return c == '\r' || c == '\n';});
            std::string data(it, it_tmp);
            check_no_endl(data);
            while(!data.empty() && *data.begin() == ' ')
                data = std::string(data.begin() + 1, data.end());;

            if(type == "table") {
            }
            else if(type == "index") {
            }
            else if(type == "field") {
                sk.add_field(data);
            }
            else if(type == "LocalTimeField") {
            }
            else if(type == "msgid") {
                sk.msgid = lexical_cast<uint32_t>(data);
            }
            else if(type == "request") {
                sk.request = lexical_cast<bool>(data);
            }
            else if(type == "reply") {
                sk.reply = lexical_cast<bool>(data);
            }
            else if(type == "replies") {
                sk.set_replies(data);
            }
            else if(type == "nullable") {
                sk.set_nullable(data);
            }
            else if(type == "hint") {
                //what is this?
            }
            else if(type == "isSyncService") {
            }
            else if(type == "REC_TIME_FIELD") {
            }
            else
                throw std::runtime_error(es() % "unknown type: " % type);

            if(it_tmp == it_e)
                break;
            it = it_tmp + 1;
        }
    }
    sk.commit(ctx, true, ini_from, it);
}

void parse_file(context& ctx, const std::vector<char>& data, const std::string& fname)
{
    try {
        parse_file(ctx, data);
    }
    catch(std::exception& e) {
        throw std::runtime_error(es() % fname % ": " % e.what());
    }
}

std::vector<std::string> list_folder(const std::string& ini_folder)
{
    std::vector<std::string> files;

    /*namespace fs = boost::filesystem;
    fs::directory_iterator it(ini_folder), it_e;
    for(; it != it_e; ++it) {
        if(it->status().type() == fs::regular_file && it->path().extension() == ".ini")
            files.push_back(it->leaf());
    }
    */

    std::unique_ptr<DIR, int(*)(DIR*)> dp(opendir(ini_folder.c_str()), &closedir);
    if(!dp)
        throw std::runtime_error(es() % "opening directory \'" % ini_folder % "\' error");
    dirent *dirp;

    while((dirp = readdir(dp.get())) != NULL) {
        std::string fname = dirp->d_name;
        if(dirp->d_type == DT_REG && fname.size() > 4 && *fname.rbegin() == 'i' && *(fname.rbegin() + 1) == 'n'
         && *(fname.rbegin() + 2) == 'i' && *(fname.rbegin() + 3) == '.')
            files.push_back(fname);
    }
    return files;
}

void parse_all(const std::string& ini_folder, const std::string& out_file)
{
    std::vector<std::string> files = list_folder(ini_folder);
    context ctx(out_file);
    for(auto&& fname: files) {
        ctx.cur_namespace = namespace_type();
        std::cout << "file: " << fname << std::endl;
        ctx.sf << "// file: " << fname << std::endl;
        parse_file(ctx, read_file((ini_folder + "/" + fname).c_str()), fname);
    }
    std::map<std::string, namespace_type> unique_tables;
    {
        for(const auto& i : ctx.saved_structures) {
            for(const auto& ii : i.second) {
                auto it = unique_tables.find(ii.first);
                if(it == unique_tables.end())
                    unique_tables[ii.first] = i.first;
                else
                    it->second = namespace_type();
            }
        }
    }
    for(const auto& v: unique_tables) {
        if(v.second != namespace_type())
            ctx.sf << "using " << v.second.first << "::" << v.second.second << "::" << v.first << ";" << std::endl;
    }
    std::cout << out_file << " successfully written" << std::endl;
}

struct source : context
{
    std::string name;
    namespace_type ns;
    std::set<std::string> tables;

    std::ofstream ini_out;

    source(const std::string& name)
        try : context(name + ".inl"), name(name), ini_out((name + ".ini").c_str(), std::ios::trunc)
    {
        ini_out.exceptions(std::ios::badbit | std::ios::failbit);
        fi = &ini_out;
    }
    catch(std::exception& e) {
        throw_system_failure(es() % "open " % name % ": " % e.what());
    }
    void write_head(const std::string& fname) {
        sf << "const char* cfg_cli_" << fname << " = \"p2repl://" << ns.first
            << ";scheme=|FILE|" << name << ".ini|" << ns.second << "\";" << std::endl << std::endl;

        ini_out << "[dbscheme:" << ns.second << "]\r\n";
        for(auto&& s: tables)
            ini_out << "table=" << s << "\r\n";
        ini_out << "\r\n";
    }
    std::stringstream tail;
    void write_cpp_tail() {
        sf << tail.str();
    }
    bool need_save() {
        if(ns == cur_namespace) {
            std::set<std::string>::iterator it = tables.find(table_name);
            if(it != tables.end()) {
                tables.erase(it);
                tail << "using " << ns.first << "::" << ns.second << "::" << table_name << ";" << std::endl;
                return true;
            }
        }
        return false;
    }
    void check_fill() {
        if(!tables.empty())
            throw std::runtime_error(es() % "source \'" % name % "\' not filled");
    }
};

void proceed_selected(const std::string& ini_folder, const std::string& scheme, const std::string& out_folder)
{
    std::vector<std::unique_ptr<source> > sources;
    {
        auto sc = read_file(scheme.c_str());
        auto it = sc.begin(), ie = sc.end();
        while(it != ie)
        {
            while(it != ie && *it == '\n')
                ++it;
            if(it == ie)
                break;
            auto ii = std::find(it, ie, '\n');
            if(*it != ';') {
                std::vector<std::string> vs = split(std::string(it, ii), ';');
                if(vs.size() != 4)
                    throw std::runtime_error(es() % "bad schema source: " % std::string(it, ii));
                std::vector<std::string> tables = split(vs[3], ',');

                std::unique_ptr<source> s(new source(out_folder + "/" + vs[0]));
                s->ns = namespace_type(vs[1], vs[2]);
                std::copy(tables.begin(), tables.end(), std::inserter(s->tables, s->tables.begin()));
                s->write_head(vs[0]);
                sources.push_back(std::move(s));
            }
            it = ii;
        }
    }
    
    std::vector<std::string> files = list_folder(ini_folder);
    for(const std::string& fname: files) {
        auto data = read_file((ini_folder + "/" + fname).c_str());
        for(std::unique_ptr<source>& s: sources) {
            s->cur_namespace = namespace_type();
            parse_file(*s, data, fname);
        }
    }

    std::stringstream str;
    for(uint32_t i = 0; i != sources.size(); ++i) {
        source& s = *sources[i];
        if(i)
            str << ",";
        str << s.name;
        s.check_fill();
        s.write_cpp_tail();
    }
    std::cout << "sources " << str.str() << " successfully saved" << std::endl;
}

int main(int argc, const char** argv)
{
    try {
        if(argc != 2 && argc != 4) {
            std::cout << "Usage:" << std::endl
                << "    ./plaza_templater scheme_folder" << std::endl
                << "    ./plaza_templater scheme_folder part_scheme_file output_folder" << std::endl;
            return 1;
        }
        if(argc == 2)
            parse_all(argv[1], "plaza_template.inl");
        else
            proceed_selected(argv[1], argv[2], argv[3]);

        return 0;
    }
    catch(std::exception& e) {
        std::cerr << "exception: " << e.what() << std::endl;
    	return 2;
    }
}

